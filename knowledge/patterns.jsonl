{"id":"P-001","type":"frontend","name":"Loading State Pattern","description":"Always show loading indicator during async operations","code":"const [loading, setLoading] = useState(true);\nuseEffect(() => {\n  fetchData().finally(() => setLoading(false));\n}, []);\nif (loading) return <LoadingSpinner />;","tags":["react","loading","async","ux"],"confidence":0.95,"uses":0}
{"id":"P-002","type":"frontend","name":"Empty State Pattern","description":"Show meaningful UI when data array is empty","code":"if (items.length === 0) {\n  return <EmptyState message=\"No items found\" action={<Button>Create First</Button>} />;\n}","tags":["react","empty","ux","list"],"confidence":0.95,"uses":0}
{"id":"P-003","type":"frontend","name":"Error Handling Pattern","description":"Catch and display errors gracefully","code":"const [error, setError] = useState<string | null>(null);\ntry {\n  await api.call();\n} catch (e) {\n  setError(e instanceof Error ? e.message : 'Unknown error');\n}\nif (error) return <ErrorAlert message={error} onRetry={retry} />;","tags":["react","error","async","ux"],"confidence":0.95,"uses":0}
{"id":"P-004","type":"frontend","name":"Safe Lookup with Map","description":"Use Map for O(1) lookups instead of array.find()","code":"const itemMap = useMemo(\n  () => new Map(items.map(i => [i.id, i])),\n  [items]\n);\nconst item = itemMap.get(id);","tags":["react","performance","map","lookup"],"confidence":0.98,"uses":0}
{"id":"P-005","type":"frontend","name":"Null Check Before Access","description":"Always check for null/undefined before accessing properties","code":"const customer = customers.find(c => c.id === id);\nif (!customer) {\n  return <NotFound message=\"Customer not found\" />;\n}\nreturn <CustomerDetails customer={customer} />;","tags":["react","null","safety","typescript"],"confidence":0.98,"uses":0}
{"id":"P-006","type":"backend","name":"Tenant Isolation Pattern","description":"Always include tenant_id in WHERE clauses","code":"SELECT * FROM jobs WHERE id = $1 AND tenant_id = $2","tags":["sql","security","tenant","database"],"confidence":1.0,"uses":0}
{"id":"P-007","type":"backend","name":"Parameterized Query Pattern","description":"Never concatenate strings in SQL queries","code":"await db.query(\n  'SELECT * FROM users WHERE email = $1 AND tenant_id = $2',\n  [email, tenantId]\n);","tags":["sql","security","injection","database"],"confidence":1.0,"uses":0}
{"id":"P-008","type":"backend","name":"Route Error Handling","description":"Wrap route handlers in try-catch with next(error)","code":"router.post('/', async (req, res, next) => {\n  try {\n    const result = await service.create(req.body);\n    res.status(201).json({ success: true, data: result });\n  } catch (error) {\n    next(error);\n  }\n});","tags":["express","error","route","api"],"confidence":0.95,"uses":0}
{"id":"P-009","type":"backend","name":"Zod Validation Pattern","description":"Validate input with Zod schemas in routes","code":"const CreateSchema = z.object({\n  title: z.string().min(1).max(200),\n  email: z.string().email(),\n});\nconst input = CreateSchema.parse(req.body);","tags":["zod","validation","api","typescript"],"confidence":0.95,"uses":0}
{"id":"P-010","type":"backend","name":"Webhook Signature Verification","description":"Always verify webhook signatures before processing","code":"const isValid = verifySignature(\n  req.body,\n  req.headers['x-signature'],\n  secret\n);\nif (!isValid) {\n  return res.status(401).json({ error: 'Invalid signature' });\n}","tags":["webhook","security","api","signature"],"confidence":1.0,"uses":0}
{"id":"P-011","type":"frontend","name":"Form State Pattern","description":"Use react-hook-form for form state management","code":"const { register, handleSubmit, formState: { errors } } = useForm<FormData>();\nconst onSubmit = async (data: FormData) => {\n  setLoading(true);\n  try {\n    await api.submit(data);\n    toast.success('Saved!');\n  } catch (e) {\n    toast.error('Failed to save');\n  } finally {\n    setLoading(false);\n  }\n};","tags":["react","form","validation","hook-form"],"confidence":0.9,"uses":0}
{"id":"P-012","type":"frontend","name":"Modal State Pattern","description":"Use controlled modal state with proper cleanup","code":"const [isOpen, setIsOpen] = useState(false);\nconst [editItem, setEditItem] = useState<Item | null>(null);\n\nconst openEdit = (item: Item) => {\n  setEditItem(item);\n  setIsOpen(true);\n};\n\nconst closeModal = () => {\n  setIsOpen(false);\n  setEditItem(null);\n};","tags":["react","modal","state","ux"],"confidence":0.9,"uses":0}
{"id":"P-013","type":"backend","name":"Transaction Pattern","description":"Use transactions for multi-table operations","code":"const client = await db.getClient();\ntry {\n  await client.query('BEGIN');\n  await client.query('INSERT INTO jobs...', [...]);\n  await client.query('INSERT INTO line_items...', [...]);\n  await client.query('COMMIT');\n} catch (e) {\n  await client.query('ROLLBACK');\n  throw e;\n} finally {\n  client.release();\n}","tags":["sql","transaction","database","consistency"],"confidence":0.95,"uses":0}
{"id":"P-014","type":"backend","name":"Domain Error Pattern","description":"Use typed domain errors instead of generic errors","code":"export class JobNotFoundError extends DomainError {\n  readonly code = 'JOB_NOT_FOUND';\n  readonly statusCode = 404;\n  constructor(id: string) {\n    super(`Job not found: ${id}`);\n  }\n}","tags":["error","domain","typescript","ddd"],"confidence":0.9,"uses":0}
{"id":"P-015","type":"frontend","name":"Optimistic Update Pattern","description":"Update UI immediately, rollback on error","code":"const deleteItem = async (id: string) => {\n  const prev = items;\n  setItems(items.filter(i => i.id !== id));\n  try {\n    await api.delete(id);\n  } catch (e) {\n    setItems(prev);\n    toast.error('Delete failed');\n  }\n};","tags":["react","optimistic","ux","state"],"confidence":0.85,"uses":0}
